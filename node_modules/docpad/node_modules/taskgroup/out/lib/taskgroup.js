// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, Interface, Task, TaskGroup, ambi, csextends, domain, events, queue, util, wait, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  queue = (typeof global !== "undefined" && global !== null ? global.setImmediate : void 0) || process.nextTick;

  events = require('events');

  domain = (_ref = ((function() {
    try {
      return require('domain');
    } catch (_error) {}
  })())) != null ? _ref : null;

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  ambi = require('ambi');

  csextends = require('csextends');

  wait = function(delay, fn) {
    return setTimeout(fn, delay);
  };

  Interface = (function(_super) {
    __extends(Interface, _super);

    function Interface() {
      var me;
      Interface.__super__.constructor.apply(this, arguments);
      me = this;
      this.on('error', function() {
        var args, err;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        err = args[0];
        if (me.listeners('done').length !== 0) {
          return this.emit.apply(this, ['done'].concat(__slice.call(args)));
        } else if (err && me.listeners('error').length === 1) {
          console.error(err.stack || err);
          throw err;
        }
      });
      this.on('completed', function() {
        var args, err;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        err = args[0];
        if (me.listeners('done').length !== 0) {
          return this.emit.apply(this, ['done'].concat(__slice.call(args)));
        } else if (err && me.listeners('completed').length === 1) {
          console.error(err.stack || err);
          throw err;
        }
      });
      this;
    }

    Interface.prototype.complete = function() {
      var err;
      err = (function() {
        throw Error('interface should provide this');
      })();
      this.emit('error', err);
      return this;
    };

    Interface.prototype.whenDone = function(listener) {
      if (typeof listener === 'function') {
        this.on('done', listener.bind(this));
      }
      return this;
    };

    Interface.prototype.onceDone = function(listener) {
      if (typeof listener === 'function') {
        this.once('done', listener);
      }
      return this;
    };

    Interface.prototype.done = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.onceDone.apply(this, args);
    };

    Interface.prototype.getNames = function(opts) {
      var name, names, _ref1;
      if (opts == null) {
        opts = {};
      }
      if (opts.format == null) {
        opts.format = 'string';
      }
      if (opts.separator == null) {
        opts.separator = ' âžž  ';
      }
      names = ((_ref1 = this.config.parent) != null ? _ref1.getNames({
        format: 'array'
      }) : void 0) || [];
      if (name = this.getName()) {
        names.push(name);
      }
      if (opts.format !== 'array') {
        names = names.join(opts.separator);
      }
      return names;
    };

    Interface.prototype.getName = function() {
      var _base;
      return (_base = this.config).name != null ? _base.name : _base.name = "" + this.type + " " + (Math.random());
    };

    Interface.prototype.getConfig = function() {
      return this.config;
    };

    return Interface;

  })(EventEmitter);

  Task = (function(_super) {
    __extends(Task, _super);

    Task.prototype.type = 'task';

    Task.isTask = function(item) {
      return (item != null ? item.type : void 0) === 'task' || item instanceof Task;
    };

    Task.subclass = csextends;

    Task.create = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this, args, function(){});
    };

    Task.prototype.err = null;

    Task.prototype.result = null;

    Task.prototype.status = null;

    Task.prototype.events = null;

    Task.prototype.taskDomain = null;

    Task.prototype.config = null;

    function Task() {
      var args, _base, _base1, _base2, _base3;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Task.__super__.constructor.apply(this, arguments);
      if (this.config == null) {
        this.config = {};
      }
      if ((_base = this.config).run == null) {
        _base.run = false;
      }
      if ((_base1 = this.config).onError == null) {
        _base1.onError = 'exit';
      }
      if ((_base2 = this.config).ambi == null) {
        _base2.ambi = true;
      }
      if ((_base3 = this.config).domain == null) {
        _base3.domain = true;
      }
      if (this.events == null) {
        this.events = [];
      }
      this.events.push('error', 'started', 'running', 'failed', 'passed', 'completed', 'done', 'destroyed');
      this.setConfig(args);
      this;
    }

    Task.prototype.setConfig = function(opts) {
      var arg, args, key, value, _i, _key, _len, _value;
      if (opts == null) {
        opts = {};
      }
      if (Array.isArray(opts)) {
        args = opts;
        opts = {};
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (!arg) {
            continue;
          }
          switch (typeof arg) {
            case 'string':
              opts.name = arg;
              break;
            case 'function':
              opts.method = arg;
              break;
            case 'object':
              for (key in arg) {
                if (!__hasProp.call(arg, key)) continue;
                value = arg[key];
                opts[key] = value;
              }
          }
        }
      }
      for (key in opts) {
        if (!__hasProp.call(opts, key)) continue;
        value = opts[key];
        switch (key) {
          case 'on':
            for (_key in value) {
              if (!__hasProp.call(value, _key)) continue;
              _value = value[_key];
              if (value) {
                this.on(_key, _value);
              }
            }
            break;
          case 'once':
            for (_key in value) {
              if (!__hasProp.call(value, _key)) continue;
              _value = value[_key];
              if (value) {
                this.once(_key, _value);
              }
            }
            break;
          case 'whenDone':
            if (value) {
              this.whenDone(value);
            }
            break;
          case 'onceDone':
          case 'done':
          case 'next':
            if (value) {
              this.done(value);
            }
            break;
          default:
            this.config[key] = value;
        }
      }
      return this;
    };

    Task.prototype.hasStarted = function() {
      return this.status !== null;
    };

    Task.prototype.hasExited = function() {
      var _ref1;
      return (_ref1 = this.status) === 'completed' || _ref1 === 'destroyed';
    };

    Task.prototype.isDestroyed = function() {
      return this.status === 'destroyed';
    };

    Task.prototype.isComplete = function() {
      var _ref1;
      return (_ref1 = this.status) === 'failed' || _ref1 === 'passed' || _ref1 === 'destroyed';
    };

    Task.prototype.exit = function() {
      var args, err;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] != null) {
        if (this.err == null) {
          this.err = args[0];
        }
      }
      if (this.isComplete() === false) {
        if (args.length !== 0) {
          this.result = args;
        }
        this.status = (this.err != null ? 'failed' : 'passed');
        this.emit(this.status, this.err);
        this.complete();
      } else if (this.config.onError !== 'ignore') {
        err = new Error("The task [" + (this.getNames()) + "] just completed, but it had already completed earlier, this is unexpected. State information is:\n" + (util.inspect({
          error: this.err,
          previousResult: this.result,
          currentArguments: args
        })));
        this.emit('error', err);
      }
      return this;
    };

    Task.prototype.complete = function() {
      var complete;
      complete = this.isComplete();
      if (complete) {
        this.emit.apply(this, ['completed'].concat(__slice.call(this.result || [])));
        this.err = null;
      }
      return complete;
    };

    Task.prototype.whenDone = function(listener) {
      if (this.isComplete()) {
        queue((function(_this) {
          return function() {
            return listener.apply(_this, _this.result || []);
          };
        })(this));
      } else {
        Task.__super__.whenDone.call(this, listener);
      }
      return this;
    };

    Task.prototype.onceDone = function(listener) {
      if (this.isComplete()) {
        queue((function(_this) {
          return function() {
            return listener.apply(_this, _this.result || []);
          };
        })(this));
      } else {
        Task.__super__.onceDone.call(this, listener);
      }
      return this;
    };

    Task.prototype.resetResults = function() {
      this.result = [];
      return this;
    };

    Task.prototype.destroy = function() {
      this.done((function(_this) {
        return function() {
          if (_this.status === 'destroyed') {
            return;
          }
          _this.emit(_this.status = 'destroyed');
          _this.resetResults();
          return _this.removeAllListeners();
        };
      })(this));
      return this;
    };

    Task.prototype.fire = function() {
      var args, err, fire, me;
      me = this;
      if ((me.config.method != null) === false) {
        err = new Error("The task [" + (me.getNames()) + "] failed to run as no method was defined for it.");
        me.emit('error', err);
        return this;
      }
      args = (this.config.args || []).concat([this.exit.bind(this)]);
      if (this.config.domain !== false && (this.taskDomain != null) === false && ((domain != null ? domain.create : void 0) != null)) {
        this.taskDomain = domain.create();
        this.taskDomain.on('error', this.exit.bind(this));
      }
      fire = function() {
        var methodToFire, _ref1;
        try {
          if ((_ref1 = me.config.method) != null ? _ref1.bind : void 0) {
            methodToFire = me.config.method.bind(me);
            me.emit(me.status = 'running');
            if (me.config.timeout) {
              me.timeout = wait(me.config.timeout, function() {
                if (me.isComplete() === false) {
                  err = new Error("The task [" + (me.getNames()) + "] has timed out.");
                  return me.exit(err);
                }
              });
            }
            if (me.config.ambi !== false) {
              return ambi.apply(null, [methodToFire].concat(__slice.call(args)));
            } else {
              return methodToFire.apply(null, args);
            }
          } else {
            err = new Error("The task [" + (me.getNames()) + "] was fired but has no method to fire");
            throw err;
          }
        } catch (_error) {
          err = _error;
          return me.exit(err);
        }
      };
      if (this.taskDomain != null) {
        this.taskDomain.run(fire);
      } else {
        fire();
      }
      return this;
    };

    Task.prototype.run = function() {
      queue((function(_this) {
        return function() {
          var err;
          if (_this.hasStarted()) {
            err = new Error("The task [" + (_this.getNames()) + "] was just about to start, but it already started earlier, this is unexpected.");
            return _this.emit('error', err);
          } else {
            _this.emit(_this.status = 'started');
            return _this.fire();
          }
        };
      })(this));
      return this;
    };

    return Task;

  })(Interface);

  TaskGroup = (function(_super) {
    __extends(TaskGroup, _super);

    TaskGroup.prototype.type = 'taskgroup';

    TaskGroup.isTaskGroup = function(group) {
      return (group != null ? group.type : void 0) === 'taskgroup' || group instanceof TaskGroup;
    };

    TaskGroup.subclass = csextends;

    TaskGroup.create = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this, args, function(){});
    };

    TaskGroup.prototype.itemsRemaining = null;

    TaskGroup.prototype.itemsRunning = null;

    TaskGroup.prototype.itemsCompleted = null;

    TaskGroup.prototype.results = null;

    TaskGroup.prototype.err = null;

    TaskGroup.prototype.status = null;

    TaskGroup.prototype.events = null;

    TaskGroup.prototype.config = null;

    function TaskGroup() {
      var args, me, _base, _base1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      me = this;
      TaskGroup.__super__.constructor.apply(this, arguments);
      if (this.config == null) {
        this.config = {};
      }
      if ((_base = this.config).concurrency == null) {
        _base.concurrency = 1;
      }
      if ((_base1 = this.config).onError == null) {
        _base1.onError = 'exit';
      }
      if (this.itemsRemaining == null) {
        this.itemsRemaining = [];
      }
      if (this.itemsRunning == null) {
        this.itemsRunning = [];
      }
      if (this.itemsCompleted == null) {
        this.itemsCompleted = [];
      }
      if (this.results == null) {
        this.results = [];
      }
      if (this.events == null) {
        this.events = [];
      }
      this.events.push('error', 'started', 'running', 'passed', 'failed', 'completed', 'done', 'destroyed');
      this.setConfig(args);
      queue(this.autoRun.bind(this));
      this;
    }

    TaskGroup.prototype.setNestedTaskConfig = function(config) {
      var key, value, _base;
      if (config == null) {
        config = {};
      }
      if ((_base = this.config).nestedTaskConfig == null) {
        _base.nestedTaskConfig = {};
      }
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        this.config.nestedTaskConfig[key] = value;
      }
      return this;
    };

    TaskGroup.prototype.setNestedConfig = function(config) {
      var key, value, _base;
      if (config == null) {
        config = {};
      }
      this.setConfig(config);
      if ((_base = this.config).nestedConfig == null) {
        _base.nestedConfig = {};
      }
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        this.config.nestedConfig[key] = value;
      }
      return this;
    };

    TaskGroup.prototype.setConfig = function(opts) {
      var arg, args, key, value, _i, _key, _len, _value;
      if (opts == null) {
        opts = {};
      }
      if (Array.isArray(opts)) {
        args = opts;
        opts = {};
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (!arg) {
            continue;
          }
          switch (typeof arg) {
            case 'string':
              opts.name = arg;
              break;
            case 'function':
              opts.method = arg;
              break;
            case 'object':
              for (key in arg) {
                if (!__hasProp.call(arg, key)) continue;
                value = arg[key];
                opts[key] = value;
              }
          }
        }
      }
      for (key in opts) {
        if (!__hasProp.call(opts, key)) continue;
        value = opts[key];
        switch (key) {
          case 'on':
            for (_key in value) {
              if (!__hasProp.call(value, _key)) continue;
              _value = value[_key];
              if (value) {
                this.on(_key, _value);
              }
            }
            break;
          case 'once':
            for (_key in value) {
              if (!__hasProp.call(value, _key)) continue;
              _value = value[_key];
              if (value) {
                this.once(_key, _value);
              }
            }
            break;
          case 'whenDone':
            if (value) {
              this.whenDone(value);
            }
            break;
          case 'onceDone':
          case 'done':
          case 'next':
            if (value) {
              this.done(value);
            }
            break;
          case 'task':
          case 'tasks':
            if (value) {
              this.addTasks(value);
            }
            break;
          case 'group':
          case 'groups':
            if (value) {
              this.addGroups(value);
            }
            break;
          case 'item':
          case 'items':
            if (value) {
              this.addItems(value);
            }
            break;
          default:
            this.config[key] = value;
        }
      }
      return this;
    };

    TaskGroup.prototype.addMethod = function(method, config) {
      if (config == null) {
        config = {};
      }
      if (method == null) {
        method = this.config.method.bind(this);
      }
      method.isTaskGroupMethod = true;
      if (config.name == null) {
        config.name = 'taskgroup method for ' + this.getName();
      }
      if (config.args == null) {
        config.args = [this.addGroup.bind(this), this.addTask.bind(this)];
      }
      if (config.includeInResults == null) {
        config.includeInResults = false;
      }
      return this.addTask(method, config);
    };

    TaskGroup.prototype.autoRun = function() {
      var item, _base;
      if (this.config.method) {
        item = this.addMethod();
        if ((this.config.parent != null) === false) {
          if ((_base = this.config).run == null) {
            _base.run = true;
          }
        }
      }
      if (this.config.run === true) {
        this.run();
      }
      return this;
    };

    TaskGroup.prototype.addItem = function() {
      var args, item, me, _base;
      item = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      me = this;
      if (!item) {
        return null;
      }
      item.setConfig({
        parent: this
      });
      if (args.length !== 0) {
        item.setConfig.apply(item, args);
      }
      if ((_base = item.config).name == null) {
        _base.name = "" + item.type + " " + (this.getItemsTotal() + 1) + " for " + (this.getName());
      }
      if (Task.isTask(item)) {
        if (this.config.nestedConfig != null) {
          item.setConfig(this.config.nestedConfig);
        }
        if (this.config.nestedTaskConfig != null) {
          item.setConfig(this.config.nestedTaskConfig);
        }
        item.events.forEach(function(event) {
          return item.on(event, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return me.emit.apply(me, ["task." + event, item].concat(__slice.call(args)));
          });
        });
        this.emit('task.add', item);
      } else if (TaskGroup.isTaskGroup(item)) {
        if (this.config.nestedConfig != null) {
          item.setNestedConfig(this.config.nestedConfig);
        }
        if (this.config.nestedTaskConfig != null) {
          item.setConfig({
            nestedTaskConfig: this.config.nestedTaskConfig
          });
        }
        item.events.forEach(function(event) {
          return item.on(event, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return me.emit.apply(me, ["group." + event, item].concat(__slice.call(args)));
          });
        });
        this.emit('group.add', item);
      }
      item.events.forEach(function(event) {
        return item.on(event, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return me.emit.apply(me, ["item." + event, item].concat(__slice.call(args)));
        });
      });

      /*
      		 * Bubble item error event directly
      		item.on 'error', (args...) ->
      			me.emit('error', args...)
       */
      this.emit('item.add', item);
      item.done(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return me.itemCompletionCallback.apply(me, [item].concat(__slice.call(args)));
      });
      this.itemsRemaining.push(item);
      this.fire();
      return item;
    };

    TaskGroup.prototype.addItems = function() {
      var args, item, items;
      items = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          _results.push(this.addItem.apply(this, [item].concat(__slice.call(args))));
        }
        return _results;
      }).call(this);
    };

    TaskGroup.prototype.createTask = function() {
      var args, task;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (Task.isTask(args[0])) {
        task = args[0];
        task.setConfig.apply(task, args.slice(1));
      } else {
        task = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Task, args, function(){});
      }
      return task;
    };

    TaskGroup.prototype.addTask = function() {
      var args, task;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      task = this.addItem(this.createTask.apply(this, args));
      return this;
    };

    TaskGroup.prototype.addTasks = function() {
      var args, item, items, tasks;
      items = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      tasks = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          _results.push(this.addTask.apply(this, [item].concat(__slice.call(args))));
        }
        return _results;
      }).call(this);
      return this;
    };

    TaskGroup.prototype.createGroup = function() {
      var args, taskgroup;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (TaskGroup.isTaskGroup(args[0])) {
        taskgroup = args[0];
        taskgroup.setConfig.apply(taskgroup, args.slice(1));
      } else {
        taskgroup = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(TaskGroup, args, function(){});
      }
      return taskgroup;
    };

    TaskGroup.prototype.addGroup = function() {
      var args, group;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      group = this.addItem(this.createGroup.apply(this, args));
      return this;
    };

    TaskGroup.prototype.addGroups = function() {
      var args, groups, item, items;
      items = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      groups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          _results.push(this.addGroup.apply(this, [item].concat(__slice.call(args))));
        }
        return _results;
      }).call(this);
      return this;
    };

    TaskGroup.prototype.getItemsTotal = function() {
      var completed, remaining, running, total;
      running = this.itemsRunning.length;
      remaining = this.itemsRemaining.length;
      completed = this.itemsCompleted.length;
      total = running + remaining + completed;
      return total;
    };

    TaskGroup.prototype.getItemNames = function() {
      var completed, remaining, results, running, total;
      running = this.itemsRunning.map(function(item) {
        return item.getName();
      });
      remaining = this.itemsRemaining.map(function(item) {
        return item.getName();
      });
      completed = this.itemsCompleted.map(function(item) {
        return item.getName();
      });
      results = this.results;
      total = running.length + remaining.length + completed.length;
      return {
        remaining: remaining,
        running: running,
        completed: completed,
        total: total,
        results: results
      };
    };

    TaskGroup.prototype.getItemTotals = function() {
      var completed, remaining, results, running, total;
      running = this.itemsRunning.length;
      remaining = this.itemsRemaining.length;
      completed = this.itemsCompleted.length;
      results = this.results.length;
      total = running + remaining + completed;
      return {
        remaining: remaining,
        running: running,
        completed: completed,
        total: total,
        results: results
      };
    };

    TaskGroup.prototype.hasRunning = function() {
      return this.itemsRunning.length !== 0;
    };

    TaskGroup.prototype.hasRemaining = function() {
      return this.itemsRemaining.length !== 0;
    };

    TaskGroup.prototype.hasItems = function() {
      return this.hasRunning() || this.hasRemaining();
    };

    TaskGroup.prototype.hasStarted = function() {
      return this.status !== null;
    };

    TaskGroup.prototype.hasResult = function() {
      return (this.err != null) || this.results.length !== 0;
    };

    TaskGroup.prototype.hasExited = function() {
      var _ref1;
      return (_ref1 = this.status) === 'completed' || _ref1 === 'destroyed';
    };

    TaskGroup.prototype.hasSlots = function() {
      return this.config.concurrency === 0 || this.itemsRunning.length < this.config.concurrency;
    };

    TaskGroup.prototype.shouldPause = function() {
      return this.config.onError === 'exit' && (this.err != null);
    };

    TaskGroup.prototype.shouldFire = function() {
      return this.shouldPause() === false && this.hasRemaining() && this.hasSlots();
    };

    TaskGroup.prototype.isEmpty = function() {
      return this.hasItems() === false;
    };

    TaskGroup.prototype.isPaused = function() {
      return this.shouldPause() && this.hasRunning() === false;
    };

    TaskGroup.prototype.isComplete = function() {
      return this.hasStarted() && (this.isPaused() || this.isEmpty());
    };

    TaskGroup.prototype.complete = function() {
      var complete, item, _i, _len, _ref1;
      complete = this.isComplete();
      if (complete) {
        this.emit('completed', this.err, this.results);
        this.err = null;
        _ref1 = this.itemsCompleted;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          item.destroy();
        }
        this.itemsCompleted = [];
      }
      return complete;
    };

    TaskGroup.prototype.whenDone = function(handler) {
      if (this.isComplete()) {
        queue((function(_this) {
          return function() {
            return handler.call(_this, _this.err, _this.results);
          };
        })(this));
      } else {
        TaskGroup.__super__.whenDone.call(this, handler);
      }
      return this;
    };

    TaskGroup.prototype.onceDone = function(handler) {
      if (this.isComplete()) {
        queue((function(_this) {
          return function() {
            return handler.call(_this, _this.err, _this.results);
          };
        })(this));
      } else {
        TaskGroup.__super__.onceDone.call(this, handler);
      }
      return this;
    };

    TaskGroup.prototype.resetResults = function() {
      this.results = [];
      return this;
    };

    TaskGroup.prototype.fireNextItems = function() {
      var item, items, result;
      items = [];
      while (true) {
        item = this.fireNextItem();
        if (item) {
          items.push(item);
        } else {
          break;
        }
      }
      result = items.length !== 0 ? items : false;
      return result;
    };

    TaskGroup.prototype.fireNextItem = function() {
      var fire, item, result;
      result = false;
      fire = this.shouldFire();
      if (fire) {
        if (this.status !== 'running') {
          this.emit(this.status = 'running');
        }
        item = this.itemsRemaining.shift();
        this.itemsRunning.push(item);
        item.run();
        result = item;
      }
      return result;
    };

    TaskGroup.prototype.itemCompletionCallback = function() {
      var args, index, indexError, item;
      item = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.config.onError === 'exit' && args[0]) {
        if (this.err == null) {
          this.err = args[0];
        }
      }
      index = this.itemsRunning.indexOf(item);
      if (index === -1) {
        if (this.err == null) {
          this.err = indexError = new Error("Could not find [" + (item.getNames()) + "] in the running queue");
        }
        console.error(indexError.stack || indexError);
      } else {
        this.itemsRunning = this.itemsRunning.slice(0, index).concat(this.itemsRunning.slice(index + 1));
      }
      this.itemsCompleted.push(item);
      if (item.config.includeInResults !== false) {
        this.results.push(args);
      }
      this.fire();
      return this;
    };

    TaskGroup.prototype.fire = function() {
      if (this.hasStarted()) {
        if (this.isComplete()) {
          this.exit();
        } else if (this.shouldPause() === false) {
          this.fireNextItems();
        }
      }
      return this;
    };

    TaskGroup.prototype.clear = function() {
      var item, _i, _len, _ref1;
      _ref1 = this.itemsRemaining;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        item = _ref1[_i];
        item.destroy();
      }
      this.itemsRemaining = [];
      return this;
    };

    TaskGroup.prototype.destroy = function() {
      this.clear();
      this.done((function(_this) {
        return function() {
          if (_this.status === 'destroyed') {
            return;
          }
          _this.emit(_this.status = 'destroyed');
          _this.resetResults();
          return _this.removeAllListeners();
        };
      })(this));
      return this;
    };

    TaskGroup.prototype.exit = function(err) {
      if (err != null) {
        if (this.err == null) {
          this.err = err;
        }
      }
      this.status = (this.err != null ? 'failed' : 'passed');
      this.emit(this.status, this.err);
      this.complete();
      return this;
    };

    TaskGroup.prototype.run = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      queue((function(_this) {
        return function() {
          _this.emit(_this.status = 'started');
          return _this.fire();
        };
      })(this));
      return this;
    };

    return TaskGroup;

  })(Interface);

  module.exports = {
    Task: Task,
    TaskGroup: TaskGroup
  };

}).call(this);
