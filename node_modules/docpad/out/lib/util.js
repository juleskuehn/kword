// Generated by CoffeeScript 1.7.1
(function() {
  var TaskGroup, docpadUtil, extractOptsAndCallback, pathUtil, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  pathUtil = require('path');

  _ = require('lodash');

  extractOptsAndCallback = require('extract-opts').extractOptsAndCallback;

  TaskGroup = require('taskgroup').TaskGroup;

  module.exports = docpadUtil = {
    isStandardEncoding: function(encoding) {
      var _ref;
      return (_ref = encoding.toLowerCase()) === 'ascii' || _ref === 'utf8' || _ref === 'utf-8';
    },
    getLocalDocPadExecutable: function() {
      return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');
    },
    isLocalDocPadExecutable: function() {
      var _ref;
      return _ref = docpadUtil.getLocalDocPadExecutable(), __indexOf.call(process.argv, _ref) >= 0;
    },
    getLocalDocPadExecutableExistance: function() {
      return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;
    },
    startLocalDocPadExecutable: function(next) {
      var args, command;
      args = process.argv.slice(2);
      command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);
      return require('safeps').spawn(command, {
        stdio: 'inherit'
      }, function(err) {
        var message;
        if (err) {
          if (next) {
            return next(err);
          } else {
            message = 'An error occured within the child DocPad instance: ' + err.message + '\n';
            return process.stderr.write(message);
          }
        } else {
          return typeof next === "function" ? next() : void 0;
        }
      });
    },
    getBasename: function(filename) {
      var basename;
      if (filename[0] === '.') {
        basename = filename.replace(/^(\.[^\.]+)\..*$/, '$1');
      } else {
        basename = filename.replace(/\..*$/, '');
      }
      return basename;
    },
    getExtensions: function(filename) {
      var extensions;
      extensions = filename.split(/\./g).slice(1);
      return extensions;
    },
    getExtension: function(extensions) {
      var extension;
      if (!require('typechecker').isArray(extensions)) {
        extensions = docpadUtil.getExtensions(extensions);
      }
      if (extensions.length !== 0) {
        extension = extensions.slice(-1)[0] || null;
      } else {
        extension = null;
      }
      return extension;
    },
    getDirPath: function(path) {
      return pathUtil.dirname(path) || '';
    },
    getFilename: function(path) {
      return pathUtil.basename(path);
    },
    getOutFilename: function(basename, extension) {
      if (basename === '.' + extension) {
        return basename;
      } else {
        return basename + (extension ? '.' + extension : '');
      }
    },
    getUrl: function(relativePath) {
      return '/' + relativePath.replace(/[\\]/g, '/');
    },
    getSlug: function(relativeBase) {
      return require('bal-util').generateSlugSync(relativeBase);
    },
    action: function(action, opts, next) {
      var actionMethod, actions, err, group, me, run, runner, task, _i, _len, _ref, _ref1, _ref2;
      _ref = extractOptsAndCallback(opts, next), opts = _ref[0], next = _ref[1];
      me = this;
      run = (_ref1 = opts.run) != null ? _ref1 : true;
      runner = (_ref2 = opts.runner) != null ? _ref2 : me.getActionRunner();
      if (Array.isArray(action)) {
        actions = action;
      } else {
        actions = action.split(/[,\s]+/g);
      }
      actions = _.uniq(_.compact(actions));
      if (next == null) {
        next = (function(_this) {
          return function(err) {
            if (err) {
              return _this.emit('error', err);
            }
          };
        })(this);
      }
      if (actions.length === 0) {
        err = new Error('No action was given');
        next(err);
      } else if (actions.length > 1) {
        group = runner.createGroup('actions bundle: ' + actions.join(' '));
        for (_i = 0, _len = actions.length; _i < _len; _i++) {
          action = actions[_i];
          actionMethod = me[action].bind(me);
          task = group.createTask(action, actionMethod, {
            args: [opts]
          });
          group.addTask(task);
        }
        runner.addGroup(group, {
          next: next
        });
        if (run === true) {
          runner.run();
        }
      } else {
        action = actions[0];
        actionMethod = me[action].bind(me);
        if (!actionMethod) {
          err = new Error(util.format(locale.actionNonexistant, action));
          return next(err);
        }
        task = runner.createTask(action, actionMethod, {
          args: [opts],
          next: next
        });
        runner.addTask(task);
        if (run === true) {
          runner.run();
        }
      }
      return me;
    }
  };

}).call(this);
